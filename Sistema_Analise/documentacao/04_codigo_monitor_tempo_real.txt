SCRIPT DE MONITORAMENTO EM TEMPO REAL
======================================

Este arquivo cont√©m o c√≥digo para implementar o monitor que detecta
novas respostas nos question√°rios e processa automaticamente.

ARQUIVO: monitor_tempo_real.py
==============================

```python
"""
Monitor em tempo real para processamento de question√°rios
Detecta automaticamente novas respostas e gera diagn√≥sticos
"""

import os
import json
import time
import pandas as pd
from datetime import datetime
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import logging

from processador_questionarios import ProcessadorQuestionarios
from gerador_diagnosticos import GeradorDiagnosticos

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/monitor.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class MonitorQuestionarios(FileSystemEventHandler):
    """
    Monitor que detecta mudan√ßas nos arquivos de question√°rios
    """
    
    def __init__(self, processador, gerador):
        self.processador = processador
        self.gerador = gerador
        self.controle_ids = self.carregar_controle_ids()
        self.arquivos_monitorados = {
            'questionario_estresse.xlsx': 'estresse',
            'questionario_menacme.xlsx': 'menacme',
            'questionario_personalizado.xlsx': 'personalizado'
        }
        
    def carregar_controle_ids(self):
        """Carrega arquivo de controle de IDs processados"""
        try:
            with open('controle_ids.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {
                "ultimo_id_processado": 0,
                "questionarios_processados": {
                    "estresse": [],
                    "menacme": [],
                    "personalizado": []
                },
                "ultima_atualizacao": datetime.now().isoformat()
            }
    
    def salvar_controle_ids(self):
        """Salva arquivo de controle de IDs"""
        self.controle_ids["ultima_atualizacao"] = datetime.now().isoformat()
        with open('controle_ids.json', 'w', encoding='utf-8') as f:
            json.dump(self.controle_ids, f, indent=2, ensure_ascii=False)
    
    def on_modified(self, event):
        """Detecta quando um arquivo √© modificado"""
        if event.is_directory:
            return
            
        arquivo = os.path.basename(event.src_path)
        if arquivo in self.arquivos_monitorados:
            logger.info(f"üìÑ Arquivo modificado detectado: {arquivo}")
            
            # Aguardar um pouco para arquivo ser completamente salvo
            time.sleep(2)
            
            tipo_questionario = self.arquivos_monitorados[arquivo]
            self.processar_novas_respostas(event.src_path, tipo_questionario)
    
    def processar_novas_respostas(self, caminho_arquivo, tipo_questionario):
        """Processa novas respostas encontradas no arquivo"""
        try:
            logger.info(f"üîç Verificando novas respostas em {tipo_questionario}")
            
            # Ler arquivo Excel
            xl_file = pd.ExcelFile(caminho_arquivo)
            
            # Obter IDs j√° processados deste question√°rio
            ids_processados = set(self.controle_ids["questionarios_processados"][tipo_questionario])
            
            novas_respostas = []
            
            # Verificar cada aba/planilha
            for sheet_name in xl_file.sheet_names:
                if sheet_name.startswith('Participante_') or sheet_name.isdigit():
                    # Extrair ID do participante do nome da aba
                    try:
                        if sheet_name.startswith('Participante_'):
                            id_participante = int(sheet_name.split('_')[1])
                        else:
                            id_participante = int(sheet_name)
                        
                        if id_participante not in ids_processados:
                            # Nova resposta encontrada!
                            logger.info(f"‚ú® Nova resposta encontrada: Participante {id_participante:03d}")
                            novas_respostas.append((id_participante, sheet_name))
                            
                    except (ValueError, IndexError):
                        logger.warning(f"‚ö†Ô∏è Nome de aba inv√°lido: {sheet_name}")
                        continue
            
            # Processar cada nova resposta
            for id_participante, sheet_name in novas_respostas:
                self.processar_resposta_individual(
                    caminho_arquivo, sheet_name, id_participante, tipo_questionario
                )
                
                # Adicionar √† lista de processados
                self.controle_ids["questionarios_processados"][tipo_questionario].append(id_participante)
                
                # Atualizar √∫ltimo ID processado
                if id_participante > self.controle_ids["ultimo_id_processado"]:
                    self.controle_ids["ultimo_id_processado"] = id_participante
            
            # Salvar controle atualizado
            if novas_respostas:
                self.salvar_controle_ids()
                logger.info(f"‚úÖ Processadas {len(novas_respostas)} novas respostas para {tipo_questionario}")
            else:
                logger.info(f"üìä Nenhuma nova resposta encontrada em {tipo_questionario}")
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao processar {caminho_arquivo}: {str(e)}")
    
    def processar_resposta_individual(self, caminho_arquivo, sheet_name, id_participante, tipo_questionario):
        """Processa uma resposta individual"""
        try:
            logger.info(f"‚öôÔ∏è Processando Participante {id_participante:03d} - {tipo_questionario}")
            
            # Ler dados da planilha espec√≠fica
            df = pd.read_excel(caminho_arquivo, sheet_name=sheet_name)
            
            # Processar com o sistema existente
            if tipo_questionario == 'estresse':
                resultado = self.processador.processar_estresse(df)
            elif tipo_questionario == 'menacme':
                resultado = self.processador.processar_menacme(df)
            else:
                resultado = self.processador.processar_personalizado(df)
            
            # Adicionar metadados
            resultado['id_participante'] = id_participante
            resultado['tipo_questionario'] = tipo_questionario
            resultado['timestamp_processamento'] = datetime.now().isoformat()
            
            # Salvar resultado individual
            nome_arquivo = f"participante_{id_participante:03d}_{tipo_questionario}.json"
            caminho_resultado = os.path.join("resultados", nome_arquivo)
            
            with open(caminho_resultado, 'w', encoding='utf-8') as f:
                json.dump(resultado, f, indent=2, ensure_ascii=False)
            
            # Gerar diagn√≥stico personalizado
            diagnostico = self.gerador.gerar_diagnostico_completo(resultado)
            
            # Salvar diagn√≥stico
            nome_diagnostico = f"participante_{id_participante:03d}_{tipo_questionario}.html"
            caminho_diagnostico = os.path.join("diagnosticos", nome_diagnostico)
            
            with open(caminho_diagnostico, 'w', encoding='utf-8') as f:
                f.write(diagnostico)
            
            logger.info(f"‚úÖ Participante {id_participante:03d} processado com sucesso!")
            
            # Log do resultado
            logger.info(f"üìä Resultado: {resultado.get('categoria', 'N/A')} - "
                       f"Pontua√ß√£o: {resultado.get('pontuacao_total', 'N/A')}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao processar Participante {id_participante:03d}: {str(e)}")


def verificar_estrutura_diretorios():
    """Verifica e cria diret√≥rios necess√°rios"""
    diretorios = ['dados_entrada', 'resultados', 'diagnosticos', 'logs', 'backup']
    
    for diretorio in diretorios:
        os.makedirs(diretorio, exist_ok=True)
        logger.info(f"üìÅ Diret√≥rio verificado: {diretorio}")


def executar_verificacao_inicial():
    """Executa verifica√ß√£o inicial de arquivos existentes"""
    logger.info("üîç Executando verifica√ß√£o inicial...")
    
    processador = ProcessadorQuestionarios()
    gerador = GeradorDiagnosticos(processador)
    monitor = MonitorQuestionarios(processador, gerador)
    
    # Verificar cada arquivo monitorado
    for arquivo, tipo in monitor.arquivos_monitorados.items():
        caminho_completo = os.path.join("dados_entrada", arquivo)
        if os.path.exists(caminho_completo):
            logger.info(f"üìÑ Verificando arquivo existente: {arquivo}")
            monitor.processar_novas_respostas(caminho_completo, tipo)


def main():
    """Fun√ß√£o principal do monitor"""
    print("=" * 60)
    print("üî¨ MONITOR DE QUESTION√ÅRIOS EM TEMPO REAL")
    print("   Sistema de An√°lise - Projeto PIBITI")
    print("=" * 60)
    
    # Verificar estrutura de diret√≥rios
    verificar_estrutura_diretorios()
    
    # Executar verifica√ß√£o inicial
    executar_verificacao_inicial()
    
    # Configurar monitor de arquivos
    processador = ProcessadorQuestionarios()
    gerador = GeradorDiagnosticos(processador)
    event_handler = MonitorQuestionarios(processador, gerador)
    
    observer = Observer()
    observer.schedule(event_handler, "dados_entrada", recursive=False)
    observer.start()
    
    logger.info("üëÄ Monitor iniciado! Aguardando novas respostas...")
    print("\nüëÄ Monitor ativo! Pressione Ctrl+C para parar.")
    print("üìÅ Monitorando pasta: dados_entrada/")
    print("üìä Resultados salvos em: resultados/")
    print("üìã Diagn√≥sticos salvos em: diagnosticos/")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("üõë Monitor interrompido pelo usu√°rio")
        print("\nüõë Monitor parado.")
    finally:
        observer.stop()
        observer.join()


if __name__ == "__main__":
    main()
```

COMO USAR O MONITOR
===================

1. INSTALA√á√ÉO
   pip install watchdog

2. ESTRUTURA DE PASTAS
   - Colocar arquivos Excel em: dados_entrada/
   - Resultados aparecer√£o em: resultados/
   - Diagn√≥sticos em: diagnosticos/

3. EXECU√á√ÉO
   python monitor_tempo_real.py

4. FUNCIONAMENTO
   - Detecta automaticamente quando arquivo Excel √© modificado
   - Identifica novas planilhas/abas 
   - Processa apenas participantes n√£o processados anteriormente
   - Gera resultado e diagn√≥stico automaticamente
   - Mant√©m log de todas as atividades

INTEGRA√á√ÉO COM GOOGLE FORMS
============================

Para que funcione perfeitamente:

1. Configure Google Forms para salvar em Google Sheets
2. Configure Google Sheets para:
   - Criar nova aba para cada resposta
   - Nomear abas como: "Participante_001", "Participante_002", etc.
   - Ou usar apenas n√∫meros: "1", "2", "3", etc.

3. Sincronize Google Sheets com OneDrive:
   - Exporte automaticamente para Excel
   - Salve na pasta dados_entrada/

EXEMPLO DE EXECU√á√ÉO
===================

Console Output:
```
============================================================
üî¨ MONITOR DE QUESTION√ÅRIOS EM TEMPO REAL
   Sistema de An√°lise - Projeto PIBITI
============================================================

üìÅ Diret√≥rio verificado: dados_entrada
üìÅ Diret√≥rio verificado: resultados
üìÅ Diret√≥rio verificado: diagnosticos
üìÅ Diret√≥rio verificado: logs

üîç Executando verifica√ß√£o inicial...
üìÑ Verificando arquivo existente: questionario_estresse.xlsx
‚ú® Nova resposta encontrada: Participante 001
‚öôÔ∏è Processando Participante 001 - estresse
‚úÖ Participante 001 processado com sucesso!
üìä Resultado: moderado - Pontua√ß√£o: 65

üëÄ Monitor iniciado! Aguardando novas respostas...

üìÑ Arquivo modificado detectado: questionario_estresse.xlsx
üîç Verificando novas respostas em estresse
‚ú® Nova resposta encontrada: Participante 002
‚öôÔ∏è Processando Participante 002 - estresse
‚úÖ Participante 002 processado com sucesso!
üìä Resultado: baixo - Pontua√ß√£o: 32
```
