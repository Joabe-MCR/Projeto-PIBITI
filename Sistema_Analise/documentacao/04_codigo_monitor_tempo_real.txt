SCRIPT DE MONITORAMENTO EM TEMPO REAL
======================================

Este arquivo contÃ©m o cÃ³digo para implementar o monitor que detecta
novas respostas nos questionÃ¡rios e processa automaticamente.

ARQUIVO: monitor_tempo_real.py
==============================

```python
"""
Monitor em tempo real para processamento de questionÃ¡rios
Detecta automaticamente novas respostas e gera diagnÃ³sticos
"""

import os
import json
import time
import pandas as pd
from datetime import datetime
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import logging

from processador_questionarios import ProcessadorQuestionarios
from gerador_diagnosticos import GeradorDiagnosticos

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/monitor.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class MonitorQuestionarios(FileSystemEventHandler):
    """
    Monitor que detecta mudanÃ§as nos arquivos de questionÃ¡rios
    """
    
    def __init__(self, processador, gerador):
        self.processador = processador
        self.gerador = gerador
        self.controle_ids = self.carregar_controle_ids()
        self.arquivos_monitorados = {
            'questionario_estresse.xlsx': 'estresse',
            'questionario_menacme.xlsx': 'menacme',
            'questionario_personalizado.xlsx': 'personalizado'
        }
        
    def carregar_controle_ids(self):
        """Carrega arquivo de controle de IDs processados"""
        try:
            with open('controle_ids.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {
                "ultimo_id_processado": 0,
                "questionarios_processados": {
                    "estresse": [],
                    "menacme": [],
                    "personalizado": []
                },
                "ultima_atualizacao": datetime.now().isoformat()
            }
    
    def salvar_controle_ids(self):
        """Salva arquivo de controle de IDs"""
        self.controle_ids["ultima_atualizacao"] = datetime.now().isoformat()
        with open('controle_ids.json', 'w', encoding='utf-8') as f:
            json.dump(self.controle_ids, f, indent=2, ensure_ascii=False)
    
    def on_modified(self, event):
        """Detecta quando um arquivo Ã© modificado"""
        if event.is_directory:
            return
            
        arquivo = os.path.basename(event.src_path)
        if arquivo in self.arquivos_monitorados:
            logger.info(f"ğŸ“„ Arquivo modificado detectado: {arquivo}")
            
            # Aguardar um pouco para arquivo ser completamente salvo
            time.sleep(2)
            
            tipo_questionario = self.arquivos_monitorados[arquivo]
            self.processar_novas_respostas(event.src_path, tipo_questionario)
    
    def processar_novas_respostas(self, caminho_arquivo, tipo_questionario):
        """Processa novas respostas encontradas no arquivo"""
        try:
            logger.info(f"ğŸ” Verificando novas respostas em {tipo_questionario}")
            
            # Ler arquivo Excel
            xl_file = pd.ExcelFile(caminho_arquivo)
            
            # Obter IDs jÃ¡ processados deste questionÃ¡rio
            ids_processados = set(self.controle_ids["questionarios_processados"][tipo_questionario])
            
            novas_respostas = []
            
            # Verificar cada aba/planilha
            for sheet_name in xl_file.sheet_names:
                if sheet_name.startswith('Participante_') or sheet_name.isdigit():
                    # Extrair ID do participante do nome da aba
                    try:
                        if sheet_name.startswith('Participante_'):
                            id_participante = int(sheet_name.split('_')[1])
                        else:
                            id_participante = int(sheet_name)
                        
                        if id_participante not in ids_processados:
                            # Nova resposta encontrada!
                            logger.info(f"âœ¨ Nova resposta encontrada: Participante {id_participante:03d}")
                            novas_respostas.append((id_participante, sheet_name))
                            
                    except (ValueError, IndexError):
                        logger.warning(f"âš ï¸ Nome de aba invÃ¡lido: {sheet_name}")
                        continue
            
            # Processar cada nova resposta
            for id_participante, sheet_name in novas_respostas:
                self.processar_resposta_individual(
                    caminho_arquivo, sheet_name, id_participante, tipo_questionario
                )
                
                # Adicionar Ã  lista de processados
                self.controle_ids["questionarios_processados"][tipo_questionario].append(id_participante)
                
                # Atualizar Ãºltimo ID processado
                if id_participante > self.controle_ids["ultimo_id_processado"]:
                    self.controle_ids["ultimo_id_processado"] = id_participante
            
            # Salvar controle atualizado
            if novas_respostas:
                self.salvar_controle_ids()
                logger.info(f"âœ… Processadas {len(novas_respostas)} novas respostas para {tipo_questionario}")
            else:
                logger.info(f"ğŸ“Š Nenhuma nova resposta encontrada em {tipo_questionario}")
                
        except Exception as e:
            logger.error(f"âŒ Erro ao processar {caminho_arquivo}: {str(e)}")
    
    def processar_resposta_individual(self, caminho_arquivo, sheet_name, id_participante, tipo_questionario):
        """Processa uma resposta individual"""
        try:
            logger.info(f"âš™ï¸ Processando Participante {id_participante:03d} - {tipo_questionario}")
            
            # Ler dados da planilha especÃ­fica
            df = pd.read_excel(caminho_arquivo, sheet_name=sheet_name)
            
            # Processar com o sistema existente
            if tipo_questionario == 'estresse':
                resultado = self.processador.processar_estresse(df)
            elif tipo_questionario == 'menacme':
                resultado = self.processador.processar_menacme(df)
            else:
                resultado = self.processador.processar_personalizado(df)
            
            # Adicionar metadados
            resultado['id_participante'] = id_participante
            resultado['tipo_questionario'] = tipo_questionario
            resultado['timestamp_processamento'] = datetime.now().isoformat()
            
            # Salvar resultado individual
            nome_arquivo = f"participante_{id_participante:03d}_{tipo_questionario}.json"
            caminho_resultado = os.path.join("resultados", nome_arquivo)
            
            with open(caminho_resultado, 'w', encoding='utf-8') as f:
                json.dump(resultado, f, indent=2, ensure_ascii=False)
            
            # Gerar diagnÃ³stico personalizado
            diagnostico = self.gerador.gerar_diagnostico_completo(resultado)
            
            # Salvar diagnÃ³stico
            nome_diagnostico = f"participante_{id_participante:03d}_{tipo_questionario}.html"
            caminho_diagnostico = os.path.join("diagnosticos", nome_diagnostico)
            
            with open(caminho_diagnostico, 'w', encoding='utf-8') as f:
                f.write(diagnostico)
            
            logger.info(f"âœ… Participante {id_participante:03d} processado com sucesso!")
            
            # Log do resultado
            logger.info(f"ğŸ“Š Resultado: {resultado.get('categoria', 'N/A')} - "
                       f"PontuaÃ§Ã£o: {resultado.get('pontuacao_total', 'N/A')}")
            
        except Exception as e:
            logger.error(f"âŒ Erro ao processar Participante {id_participante:03d}: {str(e)}")


def verificar_estrutura_diretorios():
    """Verifica e cria diretÃ³rios necessÃ¡rios"""
    diretorios = ['dados_entrada', 'resultados', 'diagnosticos', 'logs', 'backup']
    
    for diretorio in diretorios:
        os.makedirs(diretorio, exist_ok=True)
        logger.info(f"ğŸ“ DiretÃ³rio verificado: {diretorio}")


def executar_verificacao_inicial():
    """Executa verificaÃ§Ã£o inicial de arquivos existentes"""
    logger.info("ğŸ” Executando verificaÃ§Ã£o inicial...")
    
    processador = ProcessadorQuestionarios()
    gerador = GeradorDiagnosticos(processador)
    monitor = MonitorQuestionarios(processador, gerador)
    
    # Verificar cada arquivo monitorado
    for arquivo, tipo in monitor.arquivos_monitorados.items():
        caminho_completo = os.path.join("dados_entrada", arquivo)
        if os.path.exists(caminho_completo):
            logger.info(f"ğŸ“„ Verificando arquivo existente: {arquivo}")
            monitor.processar_novas_respostas(caminho_completo, tipo)


def main():
    """FunÃ§Ã£o principal do monitor"""
    print("=" * 60)
    print("ğŸ”¬ MONITOR DE QUESTIONÃRIOS EM TEMPO REAL")
    print("   Sistema de AnÃ¡lise - Projeto PIBITI")
    print("=" * 60)
    
    # Verificar estrutura de diretÃ³rios
    verificar_estrutura_diretorios()
    
    # Executar verificaÃ§Ã£o inicial
    executar_verificacao_inicial()
    
    # Configurar monitor de arquivos
    processador = ProcessadorQuestionarios()
    gerador = GeradorDiagnosticos(processador)
    event_handler = MonitorQuestionarios(processador, gerador)
    
    observer = Observer()
    observer.schedule(event_handler, "dados_entrada", recursive=False)
    observer.start()
    
    logger.info("ğŸ‘€ Monitor iniciado! Aguardando novas respostas...")
    print("\nğŸ‘€ Monitor ativo! Pressione Ctrl+C para parar.")
    print("ğŸ“ Monitorando pasta: dados_entrada/")
    print("ğŸ“Š Resultados salvos em: resultados/")
    print("ğŸ“‹ DiagnÃ³sticos salvos em: diagnosticos/")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("ğŸ›‘ Monitor interrompido pelo usuÃ¡rio")
        print("\nğŸ›‘ Monitor parado.")
    finally:
        observer.stop()
        observer.join()


if __name__ == "__main__":
    main()
```

COMO USAR O MONITOR
===================

1. INSTALAÃ‡ÃƒO
   pip install watchdog

2. ESTRUTURA DE PASTAS
   - Colocar arquivos Excel em: dados_entrada/
   - Resultados aparecerÃ£o em: resultados/
   - DiagnÃ³sticos em: diagnosticos/

3. EXECUÃ‡ÃƒO
   python monitor_tempo_real.py

4. FUNCIONAMENTO
   - Detecta automaticamente quando arquivo Excel Ã© modificado
   - Identifica novas planilhas/abas 
   - Processa apenas participantes nÃ£o processados anteriormente
   - Gera resultado e diagnÃ³stico automaticamente
   - MantÃ©m log de todas as atividades

INTEGRAÃ‡ÃƒO COM GOOGLE FORMS
============================

Para que funcione perfeitamente:

1. Configure Google Forms para salvar em Google Sheets
2. Configure Google Sheets para:
   - Criar nova aba para cada resposta
   - Nomear abas como: "Participante_001", "Participante_002", etc.
   - Ou usar apenas nÃºmeros: "1", "2", "3", etc.

3. Sincronize Google Sheets com OneDrive:
   - Exporte automaticamente para Excel
   - Salve na pasta dados_entrada/

EXEMPLO DE EXECUÃ‡ÃƒO
===================

Console Output:
```
============================================================
ğŸ”¬ MONITOR DE QUESTIONÃRIOS EM TEMPO REAL
   Sistema de AnÃ¡lise - Projeto PIBITI
============================================================

ğŸ“ DiretÃ³rio verificado: dados_entrada
ğŸ“ DiretÃ³rio verificado: resultados
ğŸ“ DiretÃ³rio verificado: diagnosticos
ğŸ“ DiretÃ³rio verificado: logs

ğŸ” Executando verificaÃ§Ã£o inicial...
ğŸ“„ Verificando arquivo existente: questionario_estresse.xlsx
âœ¨ Nova resposta encontrada: Participante 001
âš™ï¸ Processando Participante 001 - estresse
âœ… Participante 001 processado com sucesso!
ğŸ“Š Resultado: moderado - PontuaÃ§Ã£o: 65

ğŸ‘€ Monitor iniciado! Aguardando novas respostas...

ğŸ“„ Arquivo modificado detectado: questionario_estresse.xlsx
ğŸ” Verificando novas respostas em estresse
âœ¨ Nova resposta encontrada: Participante 002
âš™ï¸ Processando Participante 002 - estresse
âœ… Participante 002 processado com sucesso!
ğŸ“Š Resultado: baixo - PontuaÃ§Ã£o: 32
```
